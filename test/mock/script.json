"/*\n  senseBox Home - Citizen Sensingplatform\n  Version: 2.2\n  Date: 2016-08-25\n  Homepage: https://www.sensebox.de https://opensensemap.org\n  Author: Jan Wirwahn, Institute for Geoinformatics, University of Muenster\n  Note: Sketch for senseBox Home Kit\n  Email: support@sensebox.de\n*/\n\n#include <Wire.h>\n#include \"HDC100X.h\"\n#include \"BMP280.h\"\n#include <Makerblog_TSL45315.h>\n#include <SPI.h>\n#include <Ethernet.h>\n\n//senseBox ID\n#define SENSEBOX_ID \"58108ee070001e000fd7b135\"\n\n//Sensor IDs\n#define UVSENSOR_ID \"58108ee070001e000fd7b136\"\n#define LUXSENSOR_ID \"58108ee070001e000fd7b137\"\n#define PRESSURESENSOR_ID \"58108ee070001e000fd7b138\"\n#define HUMISENSOR_ID \"58108ee070001e000fd7b139\"\n#define TEMPSENSOR_ID \"58108ee070001e000fd7b13a\"\n\n//Configure ethernet connection\nIPAddress myIp(192, 168, 0, 42);\nbyte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\nchar server[] = \"osem.vo1d.space\";\nEthernetClient client;\n\n//Load sensors\nMakerblog_TSL45315 TSL = Makerblog_TSL45315(TSL45315_TIME_M4);\nHDC100X HDC(0x43);\nBMP280 BMP;\n\n//measurement variables\nfloat temperature = 0;\nfloat humidity = 0;\ndouble tempBaro, pressure;\nuint32_t lux;\nuint16_t uv;\nint messTyp;\n#define UV_ADDR 0x38\n#define IT_1   0x1\n\nconst unsigned int postingInterval = 60000;\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  // start the Ethernet connection:\n  Serial.println(\"senseBox Home software version 2.2\");\n  Serial.println();\n  Serial.print(\"Starting ethernet connection...\");\n\n  if (Ethernet.begin(mac) == 0) {\n    Serial.println(\"Failed to configure Ethernet using DHCP\");\n    Ethernet.begin(mac, myIp);\n  } else {\n    Serial.println(\"done!\");\n  }\n  delay(1000);\n  //Initialize sensors\n  Serial.print(\"Initializing sensors...\");\n  Wire.begin();\n  Wire.beginTransmission(UV_ADDR);\n  Wire.write((IT_1 << 2) | 0x02);\n  Wire.endTransmission();\n  delay(500);\n  HDC.begin(HDC100X_TEMP_HUMI, HDC100X_14BIT, HDC100X_14BIT, DISABLE);\n  TSL.begin();\n  BMP.begin();\n  BMP.setOversampling(4);\n  Serial.println(\"done!\");\n  Serial.println(\"Starting loop.\");\n  temperature = HDC.getTemp();\n}\n\nvoid loop() {\n  // if there are incoming bytes available\n  // from the server, read them and print them:\n  if (client.available()) {\n    char c = client.read();\n    Serial.print(c);\n    //Serial.write(c);\n  }\n\n  //-----Pressure-----//\n  Serial.println(\"Posting pressure\");\n  messTyp = 2;\n  char result = BMP.startMeasurment();\n  if (result != 0) {\n    delay(result);\n    result = BMP.getTemperatureAndPressure(tempBaro, pressure);\n    postObservation(pressure, PRESSURESENSOR_ID, SENSEBOX_ID);\n  }\n  delay(2000);\n  //-----Humidity-----//\n  Serial.println(\"Posting humidity\");\n  messTyp = 2;\n  humidity = HDC.getHumi();\n  postObservation(humidity, HUMISENSOR_ID, SENSEBOX_ID);\n  delay(2000);\n  //-----Temperature-----//\n  Serial.println(\"Posting temperature\");\n  messTyp = 2;\n  temperature = HDC.getTemp();\n  postObservation(temperature, TEMPSENSOR_ID, SENSEBOX_ID);\n  delay(2000);\n  //-----Lux-----//\n  Serial.println(\"Posting illuminance\");\n  messTyp = 1;\n  lux = TSL.readLux();\n  postObservation(lux, LUXSENSOR_ID, SENSEBOX_ID);\n  delay(2000);\n  //UV intensity\n  messTyp = 1;\n  uv = getUV();\n  postObservation(uv, UVSENSOR_ID, SENSEBOX_ID);\n\n  sleep(postingInterval);\n}\n\nvoid postObservation(float measurement, String sensorId, String boxId) {\n  char obs[10];\n  if (messTyp == 1) dtostrf(measurement, 5, 0, obs);\n  else if (messTyp == 2) dtostrf(measurement, 5, 2, obs);\n  Serial.println(obs);\n  //json must look like: {\"value\":\"12.5\"}\n  //post observation to: /boxes/boxId/sensorId\n  Serial.println(\"connecting...\");\n  String value = \"{\"value\":\";\n  value += obs;\n  value += \"}\";\n  if (client.connect(server, 8000))\n  {\n    Serial.println(\"connected\");\n    // Make a HTTP Post request:\n    client.print(\"POST /boxes/\");\n    client.print(boxId);\n    client.print(\"/\");\n    client.print(sensorId);\n    client.println(\" HTTP/1.1\");\n    // Send the required header parameters\n    client.print(\"Host:\");\n    client.println(server);\n    client.println(\"Content-Type: application/json\");\n    client.println(\"Connection: close\");\n    client.print(\"Content-Length: \");\n    client.println(value.length());\n    client.println();\n    // Send the data\n    client.print(value);\n    client.println();\n  }\n  waitForResponse();\n}\n\nvoid waitForResponse()\n{\n  // if there are incoming bytes available\n  // from the server, read them and print them:\n  boolean repeat = true;\n  do {\n    if (client.available())\n    {\n      char c = client.read();\n      Serial.print(c);\n    }\n    // if the servers disconnected, stop the client:\n    if (!client.connected())\n    {\n      Serial.println();\n      Serial.println(\"disconnecting.\");\n      client.stop();\n      repeat = false;\n    }\n  }\n  while (repeat);\n}\n\nuint16_t getUV() {\n  byte msb = 0, lsb = 0;\n  uint16_t uvValue;\n\n  Wire.requestFrom(UV_ADDR + 1, 1); //MSB\n  delay(1);\n  if (Wire.available()) msb = Wire.read();\n\n  Wire.requestFrom(UV_ADDR + 0, 1); //LSB\n  delay(1);\n  if (Wire.available()) lsb = Wire.read();\n\n  uvValue = (msb << 8) | lsb;\n\n  return uvValue * 5;\n}\n\n// millis() rollover fix - http://arduino.stackexchange.com/questions/12587/how-can-i-handle-the-millis-rollover\nvoid sleep(unsigned long ms) {            // ms: duration\n  unsigned long start = millis();         // start: timestamp\n  for (;;) {\n    unsigned long now = millis();         // now: timestamp\n    unsigned long elapsed = now - start;  // elapsed: duration\n    if (elapsed >= ms)                    // comparing durations: OK\n      return;\n  }\n}\n\n"